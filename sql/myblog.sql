/*
 Navicat Premium Data Transfer

 Source Server         : 本机
 Source Server Type    : MySQL
 Source Server Version : 50724
 Source Host           : localhost:3306
 Source Schema         : myblog

 Target Server Type    : MySQL
 Target Server Version : 50724
 File Encoding         : 65001

 Date: 17/09/2023 11:34:02
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for t_blog
-- ----------------------------
create database if not exists blog;

use blog;

DROP TABLE IF EXISTS `t_blog`;
CREATE TABLE `t_blog`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `appreciation` bit(1) NOT NULL DEFAULT b'0',
  `commentabled` bit(1) NOT NULL DEFAULT b'0',
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `day_views` int(255) UNSIGNED ZEROFILL NULL DEFAULT NULL,
  `create_time` datetime(0) NULL DEFAULT NULL,
  `first_picture` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `flag` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `published` bit(1) NOT NULL DEFAULT b'0',
  `recommend` bit(1) NOT NULL DEFAULT b'0',
  `share_statement` bit(1) NOT NULL DEFAULT b'0',
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `update_time` datetime(0) NULL DEFAULT NULL,
  `views` bigint(255) UNSIGNED ZEROFILL NULL DEFAULT NULL,
  `type_id` bigint(20) NULL DEFAULT NULL,
  `user_id` bigint(20) NULL DEFAULT NULL,
  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `comment_count` int(255) UNSIGNED ZEROFILL NULL DEFAULT NULL,
  `ups` int(20) UNSIGNED ZEROFILL NULL DEFAULT NULL,
  `tagIds` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `FK292449gwg5yf7ocdlmswv9w4j`(`type_id`) USING BTREE,
  INDEX `FK8ky5rrsxh01nkhctmo7d48p82`(`user_id`) USING BTREE,
  CONSTRAINT `blog_type` FOREIGN KEY (`type_id`) REFERENCES `t_type` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `blog_user` FOREIGN KEY (`user_id`) REFERENCES `t_user` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE = InnoDB AUTO_INCREMENT = 36 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_blog
-- ----------------------------
INSERT INTO `t_blog` VALUES (29, b'0', b'0', '### 我们曾如此渴望命运的波澜，到最后才发现，我们曾如此渴望命运的波澜，到最后才发现，\r\n### 少年贪玩，青年迷恋爱情，壮年汲汲于成名成家，暮年自安于自欺欺人。人寿几何，顽铁能炼成的精金，能有多少?\r\n\r\n### 人生最曼妙的风景，竟是内心的淡定与从容。人生最曼妙的风景，竟是内心的淡定与从容。人生最曼妙的风景，竟是内心的淡定与从容。人生最曼妙的风景，竟是内心的淡定与从容。\r\n', 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, '2022-09-24 11:42:19', 'https://cdn.pixabay.com/photo/2022/04/16/14/51/woman-7136446__340.jpg', '原创', b'1', b'0', b'0', '少年', '2022-09-24 14:16:51', 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005, 60, 3, '少年贪玩，青年迷恋爱情，壮年汲汲于成名成家，暮年自安于自欺欺人。人寿几何，顽铁能炼成的精金，能有多少?\r\n我们曾如此渴望命运的波澜，到最后才发现，\r\n人生最曼妙的风景，竟是内心的淡定与从容。', 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, 00000000000000000001, '12');
INSERT INTO `t_blog` VALUES (30, b'0', b'1', '# 一、什么是 缓存？\r\n缓存(Cache),就是数据交换的缓冲区,俗称的缓存就是缓冲区内的数据,一般从数据库中获取,存储于本地代码，例如：\r\n\r\n例1:Static final ConcurrentHashMap<K,V> map = new ConcurrentHashMap<>(); 本地用于高并发\r\n\r\n例2:static final Cache<K,V> USER_CACHE = CacheBuilder.newBuilder().build(); 用于redis等缓存\r\n\r\n例3:Static final Map<K,V> map =  new HashMap(); 本地缓存\r\n由于其被Static修饰,所以随着类的加载而被加载到内存之中,作为本地缓存,由于其又被final修饰,所以其引用(例3:map)和对象(例3:new HashMap())之间的关系是固定的,不能改变,因此不用担心赋值(=)导致缓存失效;\r\n\r\n## ⛅为什么用缓存？\r\n一句话总结： 因为使用了缓存后，效率会大大的提升，减少了不必要的资源消耗，提升了用户体验。\r\n\r\n但是使用缓存会增加代码复杂度和运维的成本，例如：Redis 集群，多主多从，等等\r\n\r\n\r\n\r\n## ⚡如何使用缓存\r\n在实际开发中，我们会构建缓存来提升系统的稳定、高可用性，使其性能得到进一步的提升。最常用的是 我们 本地数据与Redis 数据库结合使用\r\n\r\n浏览器缓存：主要是存在于浏览器端的缓存\r\n\r\n应用层缓存： 可以分为tomcat本地缓存，比如map集合，或者是使用redis作为缓存\r\n\r\n数据库缓存： 在数据库中有一片空间是 buffer pool （缓冲池），增改查数据都会先加载到mysql的缓存中\r\n\r\nCPU缓存： 当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存\r\n\r\n\r\n\r\n# 二、实现一个商家缓存\r\n需求说明\r\n\r\n本 项目基于 Spring Boot 整合Redis 并引入 MyBatis-Plus 来完成开发\r\n\r\n要求达到第一次加载，查询redis缓存是否存在，若不存在，则查询数据库，查询完毕后，存入redis，再次访问时只获取redis缓存中的数据，不必再次加载数据库，减轻数据库压力。\r\n⌛环境搭建\r\n本项目依赖于 3分钟搞懂阿里云服务器部署Reids并整合Spring Boot 微服务项目\r\n\r\n数据库 MySQL 8.0\r\n\r\n```sql\r\nCREATE TABLE `tb_shop` (\r\n  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT \'主键\',\r\n  `name` varchar(128) NOT NULL COMMENT \'商铺名称\',\r\n  `type_id` bigint(20) unsigned NOT NULL COMMENT \'商铺类型的id\',\r\n  `images` varchar(1024) NOT NULL COMMENT \'商铺图片，多个图片以\'\',\'\'隔开\',\r\n  `area` varchar(128) DEFAULT NULL COMMENT \'商圈，例如陆家嘴\',\r\n  `address` varchar(255) NOT NULL COMMENT \'地址\',\r\n  `x` double unsigned NOT NULL COMMENT \'经度\',\r\n  `y` double unsigned NOT NULL COMMENT \'维度\',\r\n  `avg_price` bigint(10) unsigned DEFAULT NULL COMMENT \'均价，取整数\',\r\n  `sold` int(10) unsigned zerofill NOT NULL COMMENT \'销量\',\r\n  `comments` int(10) unsigned zerofill NOT NULL COMMENT \'评论数量\',\r\n  `score` int(2) unsigned zerofill NOT NULL COMMENT \'评分，1~5分，乘10保存，避免小数\',\r\n  `open_hours` varchar(32) DEFAULT NULL COMMENT \'营业时间，例如 10:00-22:00\',\r\n  `create_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP COMMENT \'创建时间\',\r\n  `update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT \'更新时间\',\r\n  PRIMARY KEY (`id`) USING BTREE,\r\n  KEY `foreign_key_type` (`type_id`) USING BTREE\r\n) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8mb4 ROW_FORMAT=COMPACT\r\n```\r\n\r\n\r\n\r\npom依赖\r\n\r\n// Mybatis-Plus 核心依赖\r\n```java\r\n<dependency>\r\n    <groupId>com.baomidou</groupId>\r\n    <artifactId>mybatis-plus-boot-starter</artifactId>\r\n    <version>3.4.3</version>\r\n</dependency>\r\n\r\n// hutool 工具包，各种封装功能 一应俱全\r\n<dependency>\r\n    <groupId>cn.hutool</groupId>\r\n    <artifactId>hutool-all</artifactId>\r\n    <version>5.8.5</version>\r\n</dependency>\r\n```\r\n核心配置 application.yaml\r\n\r\n```java\r\nserver:\r\n  port: 8082\r\nspring:\r\n  application:\r\n    name: easydp\r\n  datasource:\r\n    driver-class-name: com.mysql.cj.jdbc.Driver\r\n    url: jdbc:mysql://127.0.0.1:3306/db_easy_dp?useSSL=false&serverTimezone=UTC\r\n    username: root\r\n    password: 111111\r\n  redis:\r\n    host: redis ip地址\r\n    port: 6379\r\n    password: redis密码，如没有不写即可\r\n    lettuce:\r\n      pool:\r\n        max-active: 10\r\n        max-idle: 10\r\n        min-idle: 1\r\n        time-between-eviction-runs: 10s\r\n  jackson:\r\n    default-property-inclusion: non_null # JSON处理时忽略非空字段\r\nmybatis-plus:\r\n  type-aliases-package: com.chen.entity # 别名扫描包\r\nlogging:\r\n  level:\r\n    com.chen: debug\r\n```\r\n## ♨️核心源码\r\n### Entity 实体类层\r\n```java\r\n\r\npackage com.chen.entity;\r\n\r\nimport com.baomidou.mybatisplus.annotation.IdType;\r\nimport com.baomidou.mybatisplus.annotation.TableField;\r\nimport com.baomidou.mybatisplus.annotation.TableId;\r\nimport com.baomidou.mybatisplus.annotation.TableName;\r\nimport lombok.Data;\r\nimport lombok.EqualsAndHashCode;\r\nimport lombok.experimental.Accessors;\r\n\r\nimport java.io.Serializable;\r\nimport java.time.LocalDateTime;\r\n\r\n/**\r\n * @author whc\r\n * @date 2022/9/3 10:29\r\n */\r\n@Data\r\n@EqualsAndHashCode(callSuper = false)\r\n@Accessors(chain = true)\r\n@TableName(\"tb_shop\")\r\npublic class ShopEntity implements Serializable {\r\n    private static final long serialVersionUID = 1L;\r\n    /**\r\n     * 主键\r\n     */\r\n    @TableId(value = \"id\", type = IdType.AUTO)\r\n    private Long id;\r\n\r\n    /**\r\n     * 商铺名称\r\n     */\r\n    private String name;\r\n\r\n    /**\r\n     * 商铺类型的id\r\n     */\r\n    private Long typeId;\r\n\r\n    /**\r\n     * 商铺图片，多个图片以\',\'隔开\r\n     */\r\n    private String images;\r\n\r\n    /**\r\n     * 商圈，例如陆家嘴\r\n     */\r\n    private String area;\r\n\r\n    /**\r\n     * 地址\r\n     */\r\n    private String address;\r\n\r\n    /**\r\n     * 经度\r\n     */\r\n    private Double x;\r\n\r\n    /**\r\n     * 维度\r\n     */\r\n    private Double y;\r\n\r\n    /**\r\n     * 均价，取整数\r\n     */\r\n    private Long avgPrice;\r\n\r\n    /**\r\n     * 销量\r\n     */\r\n    private Integer sold;\r\n\r\n    /**\r\n     * 评论数量\r\n     */\r\n    private Integer comments;\r\n\r\n    /**\r\n     * 评分，1~5分，乘10保存，避免小数\r\n     */\r\n    private Integer score;\r\n\r\n    /**\r\n     * 营业时间，例如 10:00-22:00\r\n     */\r\n    private String openHours;\r\n\r\n    /**\r\n     * 创建时间\r\n     */\r\n    private LocalDateTime createTime;\r\n\r\n    /**\r\n     * 更新时间\r\n     */\r\n    private LocalDateTime updateTime;\r\n\r\n    @TableField(exist = false)\r\n    private Double distance;\r\n}\r\n\r\n```\r\n### Mapper持久化层\r\n\r\npackage com.chen.mapper;\r\n\r\nimport com.baomidou.mybatisplus.core.mapper.BaseMapper;\r\nimport com.chen.entity.ShopEntity;\r\n\r\n/**\r\n * @author whc\r\n * @date 2022/9/3 10:33\r\n */\r\npublic interface ShopMapper extends BaseMapper<ShopEntity> {\r\n\r\n}\r\n\r\n\r\n### Service 接口\r\n\r\n```java\r\npackage com.chen.service;\r\n\r\nimport com.baomidou.mybatisplus.extension.service.IService;\r\nimport com.chen.common.ResultBean;\r\nimport com.chen.dto.ShopDTO;\r\nimport com.chen.entity.ShopEntity;\r\n\r\n/**\r\n * @author whc\r\n * @date 2022/9/3 10:35\r\n */\r\npublic interface ShopService extends IService<ShopEntity> {\r\n\r\n    ResultBean<ShopDTO> queryById(Long id);\r\n}\r\n```\r\nServiceImpl 实现层\r\n\r\n```java\r\npackage com.chen.service.impl;\r\n\r\nimport cn.hutool.core.bean.BeanUtil;\r\nimport cn.hutool.core.util.StrUtil;\r\nimport cn.hutool.json.JSONUtil;\r\nimport com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;\r\nimport com.chen.common.ResultBean;\r\nimport com.chen.dto.ShopDTO;\r\nimport com.chen.entity.ShopEntity;\r\nimport com.chen.mapper.ShopMapper;\r\nimport com.chen.service.ShopService;\r\nimport com.chen.utils.RedisConstants;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.apache.commons.lang3.StringUtils;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.cache.annotation.Cacheable;\r\nimport org.springframework.data.redis.core.StringRedisTemplate;\r\nimport org.springframework.stereotype.Service;\r\n\r\n/**\r\n * @author whc\r\n * @date 2022/9/3 10:36\r\n */\r\n@Slf4j\r\n@Service\r\npublic class ShopServiceImpl extends ServiceImpl<ShopMapper, ShopEntity> implements ShopService{\r\n\r\n    @Autowired\r\n    private StringRedisTemplate stringRedisTemplate;\r\n\r\n    @Override\r\n    public ResultBean<ShopDTO> queryById(Long id) {\r\n        try {\r\n            // 拼接 redis key\r\n            String key = RedisConstants.CACHE_SHOP_KEY + id;\r\n\r\n            //从redis中获取是否已存在，若存在，则直接返回\r\n            String json = stringRedisTemplate.opsForValue().get(key);\r\n\r\n            //判断如果存在，就返回\r\n            if (StrUtil.isNotBlank(json)) {\r\n                ShopDTO shopDTO = JSONUtil.toBean(json, ShopDTO.class);\r\n                return ResultBean.create(0, \"success\", shopDTO);\r\n            }\r\n\r\n            //从数据库查询数据	getById(id) 是 MyBatis-Plus 提供的查询方法，直接调用即可完成查询\r\n            ShopEntity shopEntity = getById(id);\r\n            //转换对象\r\n            ShopDTO shopDTO = BeanUtil.toBean(shopEntity, ShopDTO.class);\r\n\r\n            //将数据存入redis\r\n            stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shopDTO));\r\n            return ResultBean.create(0, \"success\", shopDTO);\r\n        } catch (Exception e) {\r\n            log.error(\"获取商品详情失败！ e ==> {}\", e);\r\n            return ResultBean.create(-1, \"获取商品详情失败！ e ==> {}\" + e);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n\r\nController层\r\n\r\n```java\r\npackage com.chen.controller;\r\n\r\nimport com.chen.common.ResultBean;\r\nimport com.chen.dto.ShopDTO;\r\nimport com.chen.service.ShopService;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.web.bind.annotation.*;\r\n\r\n/**\r\n * @author whc\r\n * @date 2022/9/3 11:06\r\n */\r\n@RestController\r\n@CrossOrigin\r\n@RequestMapping(\"/shop\")\r\npublic class ShopController {\r\n\r\n    @Autowired\r\n    private ShopService shopService;\r\n\r\n    @GetMapping(\"/{id}\")\r\n    public ResultBean<ShopDTO> queryShopById(@PathVariable(\"id\") Long id) {\r\n        return shopService.queryById(id);\r\n    }\r\n}\r\n\r\n```\r\n工具类\r\n\r\n```java\r\npackage com.chen.utils;\r\n\r\n/**\r\n * redis key 常量\r\n * @author whc\r\n * @date 2022/9/3 13:40\r\n */\r\npublic class RedisConstants {\r\n\r\n    public static final String CACHE_SHOP_KEY = \"cache:shop:\";\r\n\r\n    public static final Long CACHE_SHOP_TTL = 30L;\r\n}\r\n```\r\n\r\n✅测试接口\r\n这里我使用了Redis可视化工具，RESP，地址：https://resp.app/zh/\r\n\r\n打开后可以直接连接你的redis数据库，可视化展示\r\n\r\n\r\n\r\n利用 ApiFox测试接口，可参考 【云原生】前后端分离项目下 如何优雅的联调程序？\r\n\r\n\r\n第一次调用耗时 1.61s ，是因为我们第一次redis中无数据，走了查询数据库的操作，然后存入redis，总耗时1.61s\r\n\r\n第二次调用\r\n\r\n\r\n\r\n第二次调用直接走的缓存，可见效率提升了很多！\r\n\r\n三、采用 微服务 Spring Boot 注解开启缓存\r\n开启注解启动缓存\r\n\r\nSpring 默认支持缓存，但版本必须在3.1以上，在启动类加入 @EnableCaching 开启即可\r\n\r\npackage com.chen;\r\n\r\nimport org.mybatis.spring.annotation.MapperScan;\r\nimport org.springframework.boot.SpringApplication;\r\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\r\nimport org.springframework.cache.annotation.EnableCaching;\r\n\r\n/**\r\n * @author whc\r\n * @date 2022/9/3 10:27\r\n */\r\n//开启缓存支持\r\n@EnableCaching\r\n@MapperScan(\"com.chen.mapper\")\r\n@SpringBootApplication\r\npublic class MainApplication {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(MainApplication.class, args);\r\n    }\r\n}\r\n\r\n\r\n✂️@CacheEnable 注解详解\r\n@CacheEnable： 缓存存在，则使用缓存；不存在，则执行方法，并将结果塞入缓存\r\n\r\nShopServiceImpl 实现类\r\n\r\n @Cacheable(cacheNames = \"shop\", key = \"#root.methodName\")\r\n    public ShopDTO queryById(Long id) {\r\n        try {\r\n            String key = RedisConstants.CACHE_SHOP_KEY + id;\r\n\r\n            String json = stringRedisTemplate.opsForValue().get(key);\r\n\r\n            if (StrUtil.isNotBlank(json)) {\r\n                ShopDTO shopDTO = JSONUtil.toBean(json, ShopDTO.class);\r\n                return shopDTO;\r\n            }\r\n\r\n            ShopEntity shopEntity = getById(id);\r\n            //转换对象\r\n            ShopDTO shopDTO = BeanUtil.toBean(shopEntity, ShopDTO.class);\r\n\r\n            stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shopDTO), RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);\r\n            return shopDTO;\r\n        } catch (Exception e) {\r\n            log.error(\"获取商品详情失败！ e ==> {}\", e);\r\n            return null;\r\n        }\r\n    }\r\n\r\n➿调用接口测试\r\n第一次调用，耗时很长\r\n\r\n\r\n\r\n再次调用，走缓存\r\n\r\n\r\n\r\n查看Redis可视化key\r\n\r\n\r\n\r\n大小 1.11k 字节\r\n\r\n再看json存入\r\n\r\n\r\n\r\n大小 653 字节\r\n\r\n', 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003, '2022-09-24 12:07:07', 'https://img-blog.csdnimg.cn/img_convert/f47d09fbfbe2f430316852282ca6fb6a.png?x-oss-process=image/resize,m_fixed,h_150', '原创', b'1', b'0', b'0', '微服务 Spring Boot 整合Redis 实战开发解决高并发数据缓存', '2022-09-24 14:16:49', 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004, 58, 10, '微服务 Spring Boot 整合Redis 实战开发解决高并发数据缓存\r\n在高并发场景下解决数据缓存问题（Redis中存入key与存入json数据的差异）', 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, 00000000000000000001, '14,13,15');
INSERT INTO `t_blog` VALUES (31, b'0', b'1', '# 1.用String.format拼接字符串\r\n不知道你有没有拼接过字符串，特别是那种有多个参数，字符串比较长的情况。\r\n\r\n比如现在有个需求：要用get请求调用第三方接口，url后需要拼接多个参数。\r\n\r\n以前我们的请求地址是这样拼接的：\r\n\r\nString url = \"http://susan.sc.cn?userName=\"+userName+\"&age=\"+age+\"&address=\"+address+\"&sex=\"+sex+\"&roledId=\"+roleId;\r\n字符串使用+号拼接，非常容易出错。\r\n\r\n后面优化了一下，改为使用StringBuilder拼接字符串：\r\n\r\nStringBuilder urlBuilder = new StringBuilder(\"http://susan.sc.cn?\");\r\nurlBuilder.append(\"userName=\")\r\n.append(userName)\r\n.append(\"&age=\")\r\n.append(age)\r\n.append(\"&address=\")\r\n.append(address)\r\n.append(\"&sex=\")\r\n.append(sex)\r\n.append(\"&roledId=\")\r\n.append(roledId);\r\n代码优化之后，稍微直观点。\r\n\r\n但还是看起来比较别扭。\r\n\r\n这时可以使用String.format方法优化：\r\n\r\nString requestUrl = \"http://susan.sc.cn?userName=%s&age=%s&address=%s&sex=%s&roledId=%s\";\r\nString url = String.format(requestUrl,userName,age,address,sex,roledId);\r\n代码的可读性，一下子提升了很多。\r\n\r\n我们平常可以使用String.format方法拼接url请求参数，日志打印等字符串。\r\n\r\n但不建议在for循环中用它拼接字符串，因为它的执行效率，比使用+号拼接字符串，或者使用StringBuilder拼接字符串都要慢一些。\r\n\r\n\r\n# 2.创建可缓冲的IO流\r\nIO流想必大家都使用得比较多，我们经常需要把数据写入某个文件，或者从某个文件中读取数据到内存中，甚至还有可能把文件a，从目录b，复制到目录c下等。\r\n\r\nJDK给我们提供了非常丰富的API，可以去操作IO流。\r\n\r\n例如：\r\n\r\n```java\r\npublic class IoTest1 {\r\n    public static void main(String[] args) {\r\n        FileInputStream fis = null;\r\n        FileOutputStream fos = null;\r\n        try {\r\n            File srcFile = new File(\"/Users/dv_susan/Documents/workspace/jump/src/main/java/com/sue/jump/service/test1/1.txt\");\r\n            File destFile = new File(\"/Users/dv_susan/Documents/workspace/jump/src/main/java/com/sue/jump/service/test1/2.txt\");\r\n            fis = new FileInputStream(srcFile);\r\n            fos = new FileOutputStream(destFile);\r\n            int len;\r\n            while ((len = fis.read()) != -1) {\r\n                fos.write(len);\r\n            }\r\n            fos.flush();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            try {\r\n                if (fos != null) {\r\n                    fos.close();\r\n                }\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n            try {\r\n                if (fis != null) {\r\n                    fis.close();\r\n                }\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n这个例子主要的功能，是将1.txt文件中的内容复制到2.txt文件中。这例子使用普通的IO流从功能的角度来说，也能满足需求，但性能却不太好。\r\n\r\n因为这个例子中，从1.txt文件中读一个字节的数据，就会马上写入2.txt文件中，需要非常频繁的读写文件。\r\n\r\n优化：\r\n\r\n```java\r\npublic class IoTest {\r\n    public static void main(String[] args) {\r\n        BufferedInputStream bis = null;\r\n        BufferedOutputStream bos = null;\r\n        FileInputStream fis = null;\r\n        FileOutputStream fos = null;\r\n        try {\r\n            File srcFile = new File(\"/Users/dv_susan/Documents/workspace/jump/src/main/java/com/sue/jump/service/test1/1.txt\");\r\n            File destFile = new File(\"/Users/dv_susan/Documents/workspace/jump/src/main/java/com/sue/jump/service/test1/2.txt\");\r\n            fis = new FileInputStream(srcFile);\r\n            fos = new FileOutputStream(destFile);\r\n            bis = new BufferedInputStream(fis);\r\n            bos = new BufferedOutputStream(fos);\r\n            byte[] buffer = new byte[1024];\r\n            int len;\r\n            while ((len = bis.read(buffer)) != -1) {\r\n                bos.write(buffer, 0, len);\r\n            }\r\n            bos.flush();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n            try {\r\n                if (bos != null) {\r\n                    bos.close();\r\n                }\r\n                if (fos != null) {\r\n                    fos.close();\r\n                }\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n            try {\r\n                if (bis != null) {\r\n                    bis.close();\r\n                }\r\n                if (fis != null) {\r\n                    fis.close();\r\n                }\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n这个例子使用BufferedInputStream和BufferedOutputStream创建了可缓冲的输入输出流。\r\n\r\n最关键的地方是定义了一个buffer字节数组，把从1.txt文件中读取的数据临时保存起来，后面再把该buffer字节数组的数据，一次性批量写入到2.txt中。\r\n\r\n这样做的好处是，减少了读写文件的次数，而我们都知道读写文件是非常耗时的操作。也就是说使用可缓存的输入输出流，可以提升IO的性能，特别是遇到文件非常大时，效率会得到显著提升。\r\n\r\n3.减少循环次数\r\n在我们日常开发中，循环遍历集合是必不可少的操作。\r\n\r\n但如果循环层级比较深，循环中套循环，可能会影响代码的执行效率。\r\n\r\n反例：\r\n\r\n```java\r\nfor(User user: userList) {\r\n   for(Role role: roleList) {\r\n      if(user.getRoleId().equals(role.getId())) {\r\n         user.setRoleName(role.getName());\r\n      }\r\n   }\r\n}\r\n```\r\n这个例子中有两层循环，如果userList和roleList数据比较多的话，需要循环遍历很多次，才能获取我们所需要的数据，非常消耗cpu资源。\r\n\r\n正例：\r\n\r\n```java\r\nMap<Long, List<Role>> roleMap = roleList.stream().collect(Collectors.groupingBy(Role::getId));\r\nfor (User user : userList) {\r\n    List<Role> roles = roleMap.get(user.getRoleId());\r\n    if(CollectionUtils.isNotEmpty(roles)) {\r\n        user.setRoleName(roles.get(0).getName());\r\n    }\r\n}\r\n```\r\n减少循环次数，最简单的办法是，把第二层循环的集合变成map，这样可以直接通过key，获取想要的value数据。\r\n\r\n虽说map的key存在hash冲突的情况，但遍历存放数据的链表或者红黑树的时间复杂度，比遍历整个list集合要小很多。\r\n\r\n4.用完资源记得及时关闭\r\n在我们日常开发中，可能经常访问资源，比如：获取数据库连接，读取文件等。\r\n\r\n我们以获取数据库连接为例。\r\n\r\n反例：\r\n\r\n//1. 加载驱动类\r\nClass.forName(\"com.mysql.jdbc.Driver\");\r\n//2. 创建连接\r\n```java\r\nConnection connection = DriverManager.getConnection(\"jdbc:mysql//localhost:3306/db?allowMultiQueries=true&useUnicode=true&characterEncoding=UTF-8\",\"root\",\"123456\");\r\n//3.编写sql\r\nString sql =\"select * from user\";\r\n//4.创建PreparedStatement\r\nPreparedStatement pstmt = conn.prepareStatement(sql);\r\n//5.获取查询结果\r\nResultSet rs = pstmt.execteQuery();\r\nwhile(rs.next()){\r\n   int id = rs.getInt(\"id\");\r\n   String name = rs.getString(\"name\");\r\n}\r\n```\r\n上面这段代码可以正常运行，但却犯了一个很大的错误，即：ResultSet、PreparedStatement和Connection对象的资源，使用完之后，没有关闭。\r\n\r\n我们都知道，数据库连接是非常宝贵的资源。我们不可能一直创建连接，并且用完之后，也不回收，白白浪费数据库资源。\r\n\r\n正例：\r\n\r\n//1. 加载驱动类\r\n```java\r\nClass.forName(\"com.mysql.jdbc.Driver\");\r\n \r\nConnection connection = null;\r\nPreparedStatement pstmt = null;\r\nResultSet rs = null;\r\ntry {\r\n    //2. 创建连接\r\n    connection = DriverManager.getConnection(\"jdbc:mysql//localhost:3306/db?allowMultiQueries=true&useUnicode=true&characterEncoding=UTF-8\",\"root\",\"123456\");\r\n    //3.编写sql\r\n    String sql =\"select * from user\";\r\n    //4.创建PreparedStatement\r\n    pstmt = conn.prepareStatement(sql);\r\n    //5.获取查询结果\r\n    rs = pstmt.execteQuery();\r\n    while(rs.next()){\r\n       int id = rs.getInt(\"id\");\r\n       String name = rs.getString(\"name\");\r\n    }\r\n} catch(Exception e) {\r\n  log.error(e.getMessage(),e);\r\n} finally {\r\n   if(rs != null) {\r\n      rs.close();\r\n   }\r\n   \r\n   if(pstmt != null) {\r\n      pstmt.close();\r\n   }\r\n   \r\n   if(connection != null) {\r\n      connection.close();\r\n   }\r\n}\r\n```\r\n这个例子中，无论是ResultSet，或者PreparedStatement，还是Connection对象，使用完之后，都会调用close方法关闭资源。\r\n\r\n在这里温馨提醒一句：ResultSet，或者PreparedStatement，还是Connection对象，这三者关闭资源的顺序不能反了，不然可能会出现异常。\r\n\r\n5.使用池技术\r\n我们都知道，从数据库查数据，首先要连接数据库，获取Connection资源。\r\n\r\n想让程序多线程执行，需要使用Thread类创建线程，线程也是一种资源。\r\n\r\n通常一次数据库操作的过程是这样的：\r\n\r\n创建连接\r\n\r\n进行数据库操作\r\n\r\n关闭连接\r\n\r\n而创建连接和关闭连接，是非常耗时的操作，创建连接需要同时会创建一些资源，关闭连接时，需要回收那些资源。\r\n\r\n如果用户的每一次数据库请求，程序都都需要去创建连接和关闭连接的话，可能会浪费大量的时间。\r\n\r\n此外，可能会导致数据库连接过多。\r\n\r\n我们都知道数据库的最大连接数是有限的，以mysql为例，最大连接数是：100，不过可以通过参数调整这个数量。\r\n\r\n如果用户请求的连接数超过最大连接数，就会报：too many connections异常。如果有新的请求过来，会发现数据库变得不可用。\r\n\r\n这时可以通过命令：\r\n\r\nshow variables like max_connections\r\n查看最大连接数。\r\n\r\n然后通过命令：\r\n\r\nset GLOBAL max_connections=1000\r\n手动修改最大连接数。\r\n\r\n这种做法只能暂时缓解问题，不是一个好的方案，无法从根本上解决问题。\r\n\r\n最大的问题是：数据库连接数可以无限增长，不受控制。\r\n\r\n这时我们可以使用数据库连接池。\r\n\r\n目前Java开源的数据库连接池有：\r\n\r\nDBCP：是一个依赖Jakarta commons-pool对象池机制的数据库连接池。\r\n\r\nC3P0：是一个开放源代码的JDBC连接池，它在lib目录中与Hibernate一起发布，包括了实现jdbc3和jdbc2扩展规范说明的Connection 和Statement 池的DataSources 对象。\r\n\r\nDruid：阿里的Druid，不仅是一个数据库连接池，还包含一个ProxyDriver、一系列内置的JDBC组件库、一个SQL Parser。\r\n\r\nProxool：是一个Java SQL Driver驱动程序，它提供了对选择的其它类型的驱动程序的连接池封装，可以非常简单的移植到已有代码中。\r\n\r\n目前用的最多的数据库连接池是:Druid。\r\n', 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, '2022-09-24 12:22:20', 'https://img-blog.csdnimg.cn/img_convert/3687b8a1f629d73df9fa1bdbcb9a6444.png?x-oss-process=image/resize,m_fixed,h_300,image/format,png', '原创', b'1', b'0', b'0', 'JAVA中如何实现代码优化（技巧讲解）', '2022-09-24 14:16:45', 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009, 57, 8, '使用各种方法优化代码如\r\n1.用String.format拼接字符串\r\n\r\n2.创建可缓冲的IO流\r\n\r\n3.减少循环次数\r\n\r\n4.用完资源记得及时关闭\r\n\r\n5.使用池技术\r\n\r\n', 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, 00000000000000000000, '13');
INSERT INTO `t_blog` VALUES (32, b'0', b'1', 'Date类\r\njava.util.Date:表示日期和时间的类，Date 表示特定的瞬间，精确到毫秒。\r\n\r\n毫秒值的概念与作用\r\n毫秒:千分之一秒，1000毫秒=1。\r\n秒特定的瞬间:一个时间点，一刹那时间\r\n例如：\r\n2088-08-08 09:55:33:333瞬间\r\n2088-08-0809:55:33:334瞬间\r\n2088-08-08 09:55:33:335瞬间\r\n…\r\n\r\n毫秒值的作用:可以对时间和日期进行计算。\r\n2022-01-01到2088-01-01中间一共有多少天？\r\n可以日期转换为毫秒进行计算，计算完毕，在把毫秒转换为日期。\r\n\r\n把日期转换为毫秒:\r\n当前的日期:2022-08-28\r\n时间原点(0毫秒):1970年1月1日00:00:00(英国格林威治)\r\n就是计算当前日期到时间原点之间一共经历了多少毫秒(374267540068L)\r\n注意:\r\n中国属于东八区，会把时间增加8个小时1970年1月1日08:00:00\r\n\r\n把毫秒转换为日期:\r\n1天=24x60x60=86400秒=86400x1000=86400000毫秒\r\n\r\n构造方法\r\n学习类都是一个过程，先学习这个类的构造方法；有了构造方法后，就可以创建对象，然后通过对象调用它里面的成员方法。\r\n\r\n```java\r\n无参构造\r\npublic static void main(String[] args) {\r\n        //Data的空参数构造方法-Data()获取当前系统的时间（精确到毫秒的系统当前时间）\r\n        Date date = new Date();\r\n        //java.util.Date类的toString()方法已经被重写了\r\n        //所以直接输出对象，不是这个对象的内存地址，而是一个日期字符串\r\n        System.out.println(date); //输出：Sun Aug 28 21:18:47 CST 2022\r\n    }\r\n```\r\n```java\r\n有参构造\r\npublic static void main(String[] args) {\r\n        // Date类的带参数构造方法\r\n        //Date(long date) :传递毫秒值转换为Date日期\r\n        Date date = new Date(0L); //把参数里面的毫秒转成对应的日期\r\n        System.out.println(date); //输出：Thu Jan 01 08:00:00 CST 1970\r\n\r\n        Date date1 = new Date(1620543792746L); //把参数里面的毫秒转成对应的日期\r\n        System.out.println(date1); //输出：Sun May 09 15:03:12 CST 2021\r\n    }\r\n\r\n```\r\n```java\r\n成员方法getTime()\r\npublic static void main(String[] args) {\r\n        // Long getTime（）把日期转换为毫秒值（相当于System.currentTimeMillis()方法）\r\n        // 返回自1970年 1月一日 00：00：00 到当前系统时间一共经历了多少毫秒\r\n        Date date = new Date();\r\n        long time = date.getTime();\r\n        System.out.println(time); //1661693372684\r\n    }\r\n\r\n```\r\ncurrentTimeMillis方法\r\n此方法是System类的一个方法，作用和getTime()一样，返回自1970年 1月一日 00：00：00\r\n到当前系统时间一共经历了多少毫秒。\r\n\r\npublic static void main(String[] args) {\r\n        Long TimeMillis = System.currentTimeMillis();\r\n        System.out.println(TimeMillis); //输出：1661693849165\r\n    }\r\n\r\n\r\n那么这个方法可以用来干什么呢？\r\n看的出来，经过测试，下列代码空循环一亿次，用了3毫秒\r\n\r\npublic static void main(String[] args) {\r\n        //统计一个方法的耗时\r\n        //在调用目标方法之前记录一个毫秒数\r\n        Long TimeMillis = System.currentTimeMillis();\r\n        //这里调用方法\r\n        print();\r\n        //在执行完目标方法之后记录一个毫秒数\r\n        Long end = System.currentTimeMillis();\r\n\r\n        System.out.println(\"耗费时长：\"+(end-TimeMillis)+\"毫秒\"); //输出：耗费时长：3毫秒\r\n    }\r\n\r\n    public static void print(){\r\n        for (int i = 0; i < 100000000; i++) {\r\n            \r\n        }\r\n    }\r\nDateFormat和SimpleDateFormat类\r\nDateFormat类和它的子类SimpleDateFormat，后者是前者的子类，所以它有父类的format和parse方法。\r\n\r\njava.text.DateFormat:是日期/时间格式化子类的抽象类。\r\n作用: 格式化(也就是日期->文本) 、解析(文本->日期)\r\n\r\n构造方法\r\nDateFormat类是一个抽象类，无法直接创建对象使用，可以使用DateFormat类的子类\r\njava.text.SimpleDateformat extends DateFormat\r\n构造方法:\r\nSimpleDateFormat(String pattern)：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。\r\n参数: String pattern:传递指定的模式\r\n\r\n模式:区分大小写\r\n\r\ny	年\r\nM	月\r\nd	日\r\nH	时\r\nm	分\r\ns	秒\r\n写对应的模式，会把模式替换为对应的日期和时间 “yyyy-MM-dd HH:mm:ss”\r\n注意:\r\n模式中的字母不能更改，连接模式的符号可以改变\"yyyy年MM月dd日 HH时mm分ss秒\"\r\n\r\n成员方法\r\nString format(Date date)按照指定的模式，把Date日期，格式化为符合模式的字符串\r\nDate parse(String source)把符合模式的字符串，解析为Date日期\r\n\r\n使用这两个成员方法及其细节\r\npublic static void main(String[] args) throws ParseException {\r\n        demo01();\r\n        demo02(); //调用的方法也会出红线，也要光标放红线上alt+回车选择第一个\r\n    }\r\n\r\n    private static void demo01() {\r\n        //使用DateFormat类中的format方法，把日期格式转化为文本\r\n        //1.创建SimpleDateFormat对象，构造方法中传递指定的模式\r\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年mm月dd日 HH时mm分ss秒\");//传入指定的模式\r\n        //2.调用SimpleDateFormat对象中的方法format，按照构造方法中指定的模式，把Date日期格式转换为符合模式的字符串（文本）\r\n        //String format（Date date） 按照指定模式，把Date日期，格式化为符合模式的字符串\r\n        Date date =new Date(); //获取当前系统时间\r\n        String format = sdf.format(date);\r\n        System.out.println(date); //Sun May 09 16:09:50 CST 2021\r\n        System.out.println(format); //2021年09月09日 16时09分50秒\r\n    }\r\n\r\n\r\n    /*\r\n        使用DateFormat类中的parse方法，把文本解析成为Date日期\r\n        1.创建SimpleDateFormat对象，构造方法中传递指定的模式\r\n        2.调用SimpleDateFormat对象中的方法parse，把符合构造方法中模式的字符串，解析为Date日期\r\n        注意：\r\n            public Date parse(String source)throws ParsejException\r\n            parse方法声明一个异常叫ParseException\r\n            如果字符串和构造方法的模式不一样，那么程序就会抛出异常\r\n            调用一个抛出异常的方法，就必须的处理这个异常\r\n            要么throws继续抛出这个异常，要么try catch自己处理\r\n            出现红色的线，有异常，光标放红线上alt+回车选择第一个；调用的方法也会出红线，也要光标放红线上alt+回车选择第一个\r\n            这就是在我的方法声明这个异常，我不处理，我声明一下\r\n            程序没有问题，正常执行\r\n            出现问题，打印异常，并终止程序\r\n     */\r\n    private static void demo02() throws ParseException {\r\n\r\n        //使用DateFormat类中的parse方法，把文本解析成为Date日期\r\n        //1.创建SimpleDateFormat对象，构造方法中传递指定的模式\r\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年mm月dd日 HH时mm分ss秒\");//传入指定的模式\r\n\r\n        //Date parse(String source) 把符合，模式的字符串，解析为Date日期\r\n        //2.调用SimpleDateFormat对象中的方法parse，把符合构造方法中模式的字符串，解析为Date日期\r\n        /*\r\n        出现红色的线，有异常，光标放红线上alt+回车选择第一个；调用的方法也会出红线，也要光标放红线上alt+回车选择第一个\r\n        这就是在我的方法声明这个异常，我不处理，我声明一下\r\n         */\r\n//        把字符串类型按照传入构造模式解析成为Date类型，传入指定模式和字符串要一样，字符串这边少个秒就报错\r\n        Date parse = sdf.parse(\"2021年09月09日 16时09分50秒\");\r\n        System.out.println(parse);//Sat Jan 09 16:09:50 CST 2021\r\n    }\r\n练习\r\n\r\n\r\npublic static void main(String[] args) throws ParseException {\r\n        Scanner scanner = new Scanner(System.in); // 输入：2001-07-02 \r\n        System.out.println(\"请输入出生日期(格式为yyyy-mm-dd)：\");\r\n        String next = scanner.next(); //拿到字符串出生日期\r\n\r\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-mm-dd\");\r\n        Date parse = simpleDateFormat.parse(next); //把字符串出生日期解析成为DAte格式\r\n        long ee = parse.getTime(); // 把Date格式的出生日期转换为毫秒值\r\n\r\n        Date aa = new Date(); //获取当前日期毫秒值\r\n        long hh = aa.getTime(); //把当前日期毫秒值转换成为毫秒值\r\n//        Date aa = new Date().getTime(); 一步到位 匿名\r\n\r\n        long dd = hh-ee; //差值\r\n        long jj = dd/1000/60/60/24; //把毫秒值转换成为天\r\n        System.out.println(jj); // 输出：7908。 代表着 2001-07-02 到今天已经过了7908天\r\n//        System.out.println(dd/1000/60/60/24); //一步到位\r\n\r\n    }\r\nCalendar日历类\r\n常用成员方法\r\nget\r\nset\r\nadd\r\ngeiTime\r\n', 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001, '2022-09-24 13:54:39', 'https://img-blog.csdnimg.cn/dbdbceb37cd049d0857aa39855421f4a.jpeg?x-oss-process=image/resize,m_fixed,h_300,image/format,png', '原创', b'1', b'0', b'0', '【JAVA进阶篇】时间与日期相关类', '2022-09-24 14:16:42', 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006, 61, 9, 'Date类\r\n毫秒值的概念与作用\r\n构造方法\r\n无参构造\r\n有参构造\r\n成员方法getTime()\r\ncurrentTimeMillis方法\r\nDateFormat和SimpleDateFormat类\r\n构造方法\r\n成员方法\r\n使用这两个成员方法及其细节\r\n练习\r\nCalendar日历类\r\n常用成员方法\r\nget\r\nset\r\nadd\r\ngeiTime\r\n', 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, 00000000000000000000, '13');
INSERT INTO `t_blog` VALUES (33, b'0', b'1', '# 从开发角度看羊了个羊\r\n## 一、撰文背景\r\n据说最近有一款游戏名为 “羊了个羊”，风靡了各平台及社交圈。之所以用据说是因为自己一开始并没有注意到这个事情，不过由于受到 【话题达人】 勋章的召唤，还是决定写一写。\r\n![](https://img-blog.csdnimg.cn/img_convert/ed0a3175771dd643a3e7728282447288.jpeg)\r\n## 二、设计逻辑\r\n目前网络上已经可以找到很多复刻版和开源代码，已经可以勾勒出整个游戏的全貌。小编在查阅资料时，发现李永乐老师在视频中已经对游戏的设计逻辑做了整体和全面的分析，在此重新整理一下，同时在文章末尾给出一些资源链接，大家感兴趣可以自行查看。\r\n### 1. 游戏玩法\r\n![](https://img-blog.csdnimg.cn/img_convert/3fc15678e6b402aa5b4995f9bd4a00e3.png)\r\n游戏的基本核心是三消，只不过在形式上有了一些变化。在下方的操作区会有一块7个格子的空间，用来存放从草坪取下来的牌，如果凑齐三个一样的牌则会消失【不需要连续】，如果拿满了7个不能消除的牌则游戏结束，游戏的目标就是在不死的情况下清空草坪上的所有牌。\r\n在游戏的过程中，草坪上的牌是多层的，并且有些是被完全遮挡的，这就为游戏增加了难度和不确定性。当然，对于羊了个羊游戏本身源码以及实现模式我们靠外部推测是没办法完全还原的，毕竟还有运营和商业模式的因素，在牌局构建时，到底是单纯的随机还是有目的的增加死局概率这是无从得知的，毕竟游戏本身也经过多次更新，因此本文是建立在构建一个有解局的大前提下去分析设计思路。\r\n\r\n### 2. 游戏设计\r\n- 卡牌规则\r\n由于卡牌的位置是多层的，因此需要用三个坐标点来描述每个卡牌的位置：(Xi,Yi,Zi)。如果要生成一个有解牌局，则每一种卡牌要3个为一组进行生成，可以有多组，这样卡牌的总数为：卡牌种类数 X 卡牌组数 X 3，这是一个笼统的描述，因为在每一局中出现的卡牌种类数和相应的卡牌组数都可以波动。\r\n\r\n- 卡位设计\r\n根据游戏中的实际效果，不同层的卡牌之间是有遮挡关系的【可在程序实现中调整】，如果错位的卡牌比较多是属于低难度的，因为可以预先看到底层的卡，多多少少可以提前布局。还有一种情况是完全遮挡的，也就是说只有把正上方的卡牌拿走之后才能看到底层的卡牌是什么，而留给玩家的操作空间是有限的，这就增加了游戏难度。\r\n\r\n- 洗牌乱序\r\n在开始一个新的牌局时，可以通过上面描述的卡牌规则生成一个具有固定卡牌数量的牌局，卡牌种类可以调整，原则上就是种类也少，游戏越简单。因为如果卡牌总数一致，则每一种卡牌出现的组数就会相对增加，在洗牌乱序后，相同牌出现在视野中的概率就会增加。\r\n在执行完乱序之后，其实你已经成功生成了一局新的游戏了，只需要将得到的新序列填充到预先设计的卡位中就可以了，但是此时牌局是否有解是未验证的，还应该去做一个解锁逆序的自检程序，只有被认定为有解的牌局才会送到玩家面前，如果这个时候还是游戏失败，那就真的是玩家实力不济了。\r\n', 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005, '2022-09-24 15:00:23', 'https://img-blog.csdnimg.cn/img_convert/ed0a3175771dd643a3e7728282447288.jpeg', '原创', b'1', b'0', b'1', '从开发角度看羊了个羊', '2022-09-24 15:00:23', 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008, 60, 10, '浅谈羊了个羊', 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001, 00000000000000000016, '');
INSERT INTO `t_blog` VALUES (34, b'0', b'1', '#  1 问题\r\n![](https://img-blog.csdnimg.cn/img_convert/fbd154f578f51322bbc3e8cfce13ef21.png)\r\n## 2 方法\r\n### 方法一：\r\n\r\n打开 File --> settings --> Editor --> File Encodings\r\n\r\n把编码都设置为 UTF-8 的形式\r\n![](https://img-blog.csdnimg.cn/img_convert/7c8d1a4211d21059461b145d21992304.png)\r\n### 方法二：\r\n打开idea的 设置 界面，搜索 maven ，点击 Maven --> Runner --> VM Options ，填上-Dfile.encoding=GB2312\r\n![](https://img-blog.csdnimg.cn/img_convert/65cc6b790c62d530bf75e46d3f06ce0c.png)\r\n### 方法三：\r\n打开 Run --> Edit Configurations --> 选择文件\r\n\r\n在 VM options 中加上 -Dfile.encoding=UTF-8\r\n\r\n最后若以上都没有解决，则是开发工具和系统环境编码格式不匹配即为jdk版本过高，可以更换为上一版本的jdk\r\n## 3 结语\r\n针对IDEA出现中文乱码的问题，提出修改编码方式为UTF-8或GB2312，更改JDK版本的方法，通过具体的修改编码和更改jdk版本的实验，证明此类方法是有效的，当然还有其他解决此类问题的方法，未来可以继续研究还有哪些办法能够修改中文乱码。', 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002, '2022-09-24 15:05:30', 'https://img-blog.csdnimg.cn/05bf847094474f42be2557d3fe435d9c.png', '原创', b'1', b'0', b'0', '【IDEA】控制台出现中文乱码问题', '2022-09-25 01:45:52', 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009, 58, 10, '关于IDEA的常见编码问题', 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, 00000000000000000001, '10');
INSERT INTO `t_blog` VALUES (35, b'0', b'1', '想知道您是否可以在 PC 上使用 Android 操作系统？ 好吧，您来对了 Internet 上的位置。 您当然可以在您的 PC 上运行 Android。 我们已经尝试并测试了一些适用于 PC 的最佳 Android 操作系统，但与 Android 智能手机相比，在 PC 上获得相同的无缝体验非常困难。\r\n\r\n在这里，我们将讨论在 PC 上使用 Android 操作系统的最佳方式。 请注意，PC 没有成熟的桌面操作系统，这里提到的方式或方法只会帮助您在 PC 上运行它，以帮助您完成基本任务。\r\n# 安装 Android 桌面操作系统有问题吗？\r\n是的，在您的 PC 上安装 Android 操作系统并不是一个轻松的过程。 而且，在继续之前，您应该注意。\r\n\r\n这就是为什么：\r\n\r\n与 成熟的桌面操作系统，Android 作为桌面操作系统缺乏很多功能。 例如，您无法真正管理打印机，而且它也不像其他桌面操作系统那样支持以键盘为中心的界面。 此外，考虑到您可能配备了高端硬件，它不支持很多以桌面为中心的高级技术。\r\n\r\n简而言之，Android 桌面操作系统会给您带来不完整的桌面体验。 因此，您应该考虑通过一些模拟器或作为虚拟机运行 Android 操作系统，使用[ VMware](https://www.vmware.com/cn.html \" VMware\")的.\r\n# 适用于 PC 的最佳 Android 操作系统\r\n## Bluestacks\r\nBluestacks 是一款 Android 模拟器，可在您的 PC 上运行应用程序和游戏。 如果应用程序和游戏是您在 PC 上运行 Android 操作系统时唯一关心的东西，那是我们最好的选择。 这是我们将在本文中讨论的所有其他方法中最简单、最可靠的方法。\r\n![](https://img-blog.csdnimg.cn/img_convert/70ef1a8aeed0b652a64b1fb2d311c1dd.jpeg)\r\n您只需要前往他们的官方网站并下载安装文件。 无需高级设置，安装后只需单击一下即可。 此外，使用 Bluestacks，您无需担心您的硬件配置，它会检测您的配置以根据要求自动优化性能。 您只需专注于试用应用程序和游戏，而无需担心配置。\r\n[参见](https://www.techlila.com/zh-CN/top-must-have-android-apps/ \"参见\")\r\n\r\n[热门必须有 Android 应用程序](https://www.techlila.com/zh-CN/top-must-have-android-apps/ \"热门必须有 Android 应用程序\")\r\n# 安卓 x86 项目\r\nAndroid x86的 是作为 PC 的 Android 操作系统实现的最受欢迎的项目之一。 这是由一组开发人员（现在分组为一个大社区）为 PC 移植 Android 操作系统的一项非官方倡议。 它基于 AOSP，并进行了一些调整以使其与 PC 硬件（或架构）兼容。 如果你有一台英特尔驱动的机器，你应该很高兴。 我们不确定用于 Android x86 的基于 AMD 的芯片。 虽然，他们正在努力使 OpenGL ES Intel/Radeon/Nvidia/（pstglia、mauro）和 virgl(robh) GPU 的硬件加速，如其路线图中所述。\r\n![](https://img-blog.csdnimg.cn/img_convert/cf1b7d5c3e89c13de97361f9f3f78414.jpeg)\r\n但是，您如何在 PC 上安装它？ 它是适用于 PC 的最佳 Android 操作系统吗？ 正如您对任何其他操作系统所做的一样，您需要从其官方网站的下载部分下载 ISO 文件并查找正确的 ISO 文件（32 位或 64 位），然后开始下载。\r\n\r\n安装它非常容易。 您可以使用 ISO文件 直接从 USB 驱动器实时运行它，或者您可以通过 VMware 安装它。 它确实支持双启动，但我们不建议将它安装在您的生产 PC 上（除非您有一台专门用于实验和其他东西的 PC）。 如果它对你有用的话，你绝对应该为这个项目做出贡献（或捐赠）——因为这是一个非常有前途的项目，它可以很快使 Android 操作系统成为一个成熟的桌面操作系统。 Android x86 项目基于 Android Nougat 7.1 和 Android的奥利奥.\r\n# 凤凰操作系统\r\n[凤凰操作系统](http://www.phoenixos.com/en/ \"凤凰操作系统\") 基于 Android x86 项目（在某种程度上）和另一个适用于 PC 的最佳 Android 操作系统选项。 然而，它已经针对不同的用户体验进行了定制，并与已知的英国媒体报道软件（中文——这就是它的起源）一起烘焙。 如果您不介意添加的英国媒体报道软件，那么在桌面上使用应该没问题。 但是，考虑到这里已经做了很多修改，我们不建议在安装 Pheonix OS 的同时做一些重要的事情。\r\n![](https://img-blog.csdnimg.cn/img_convert/dcde5a6f155659a449658602c37ad4bb.jpeg)\r\nPheonix OS 可能被证明是最好的 Android 桌面 UI 之一。 考虑到所有因素，您应该尝试将其安装为虚拟机，因为访问您的电子邮件或执行交易不是很安全——只有当您想在没有关联敏感信息的情况下进行试验时，它才有用。\r\n# 三星Dex\r\n三星Dex 如果您希望在工作场所拥有 Android 桌面体验，这是一个非常专业的选择。 如果您想知道如何在 PC 或笔记本电脑上安装 Android，这不会解决问题。 您只需要花 150 美元购买 Samsung Dex 扩展坞即可开始使用。 您可以在家中使用它，但事实证明这是一件不方便的事情，因为它需要您拥有备用显示器、鼠标和键盘——仅适用于三星 Dex。 在任何一种情况下，将现有显示器、键盘和鼠标与台式 PC 断开连接以与 Samsung Dex 一起使用也很烦人。\r\n![](https://img-blog.csdnimg.cn/img_convert/097f659daa865f5c31b7e69a4745fdbe.jpeg)\r\n因此，对于企业使用来说，这感觉像是一个可行的解决方案，公司只需要组装显示器、键盘、鼠标和蓝牙扬声器，而无需担心系统——基本上将被三星 Dex 和 Galaxy S8/S8+ 取代或 Note 8 智能手机。 三星 Dex 提供了具有许多功能的精美用户界面。 您可以获得 HDMI、USB 2.0、USB Type C 和以太网端口。\r\n\r\n当然，如果您已经拥有 Galaxy S8/S8+ 或 Note 8。\r\n# 总结 – 适用于 PC 的 Android 操作系统\r\n您可能会发现许多适用于 PC 的 Android 发行版。 但是，其中只有少数（文章中提到的那些）可以作为获得适用于 PC 的 Android 操作系统的最久经考验的方法。 如果您不喜欢使用虚拟机设置处理 ISO 文件，Bluestacks 或 Samsung Dex 是您的不二之选。 如果您可以使用虚拟机设置，您可以尝试 Android x86 项目（推荐）或 Pheonix OS。\r\n\r\n在下面的评论中，让我们知道您对如何改进 Android 作为桌面环境的想法、您遵循的最佳方法以及一些我们不知道的有趣的 Android 桌面操作系统。\r\n[使用 Web 浏览器控制 Android 设备](https://www.techlila.com/zh-CN/how-to-control-android-device-using-web-browser/ \"使用 Web 浏览器控制 Android 设备\")', 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007, '2022-09-24 15:15:21', 'https://img-blog.csdnimg.cn/img_convert/097f659daa865f5c31b7e69a4745fdbe.jpeg', '原创', b'1', b'0', b'0', '适用于 PC 的最佳 Android 操作系统（2022 版）', '2022-09-24 15:15:21', 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010, 61, 10, '想知道您是否可以在 PC 上使用 Android 操作系统？ 好吧，您来对了', 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006, 00000000000000000001, '13');

-- ----------------------------
-- Table structure for t_blog_tags
-- ----------------------------
DROP TABLE IF EXISTS `t_blog_tags`;
CREATE TABLE `t_blog_tags`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `tag_id` bigint(20) NULL DEFAULT NULL,
  `blog_id` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 53 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of t_blog_tags
-- ----------------------------
INSERT INTO `t_blog_tags` VALUES (1, 9, '24');
INSERT INTO `t_blog_tags` VALUES (2, 10, '24');
INSERT INTO `t_blog_tags` VALUES (5, 10, '15');
INSERT INTO `t_blog_tags` VALUES (6, 11, '15');
INSERT INTO `t_blog_tags` VALUES (7, 10, '19');
INSERT INTO `t_blog_tags` VALUES (8, 11, '19');
INSERT INTO `t_blog_tags` VALUES (10, 9, '16');
INSERT INTO `t_blog_tags` VALUES (13, 10, '25');
INSERT INTO `t_blog_tags` VALUES (14, 11, '25');
INSERT INTO `t_blog_tags` VALUES (17, 10, '26');
INSERT INTO `t_blog_tags` VALUES (18, 11, '26');
INSERT INTO `t_blog_tags` VALUES (19, 10, '27');
INSERT INTO `t_blog_tags` VALUES (20, 11, '27');
INSERT INTO `t_blog_tags` VALUES (21, 10, '28');
INSERT INTO `t_blog_tags` VALUES (22, 11, '28');
INSERT INTO `t_blog_tags` VALUES (44, 13, '32');
INSERT INTO `t_blog_tags` VALUES (45, 13, '31');
INSERT INTO `t_blog_tags` VALUES (46, 13, '30');
INSERT INTO `t_blog_tags` VALUES (47, 14, '30');
INSERT INTO `t_blog_tags` VALUES (48, 15, '30');
INSERT INTO `t_blog_tags` VALUES (49, 12, '29');
INSERT INTO `t_blog_tags` VALUES (51, 13, '35');
INSERT INTO `t_blog_tags` VALUES (52, 10, '34');

-- ----------------------------
-- Table structure for t_comment
-- ----------------------------
DROP TABLE IF EXISTS `t_comment`;
CREATE TABLE `t_comment`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `content` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `create_time` datetime(0) NULL DEFAULT NULL,
  `blog_id` bigint(20) NULL DEFAULT NULL,
  `parent_comment_id` bigint(20) NULL DEFAULT NULL,
  `admin_comment` bit(1) NOT NULL DEFAULT b'0',
  `userId` int(10) UNSIGNED ZEROFILL NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `comment_blog`(`blog_id`) USING BTREE,
  INDEX `inerConect`(`parent_comment_id`) USING BTREE,
  CONSTRAINT `comment_blog` FOREIGN KEY (`blog_id`) REFERENCES `t_blog` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE = InnoDB AUTO_INCREMENT = 45 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_comment
-- ----------------------------
INSERT INTO `t_comment` VALUES (38, '牛魔', '3563433349@qq.com', '羊了个羊就是一个辣鸡游戏', '/images/bg2.jpg', '2022-09-24 15:01:03', 33, -1, b'0', 0000000010);
INSERT INTO `t_comment` VALUES (39, '牛魔', '3563433349@qq.com', '1234', '/images/bg2.jpg', '2022-09-25 08:29:44', 35, -1, b'0', 0000000010);
INSERT INTO `t_comment` VALUES (40, '牛魔', '3563433349@qq.com', 'asd', '/images/bg2.jpg', '2022-09-25 08:29:51', 35, 39, b'0', 0000000010);
INSERT INTO `t_comment` VALUES (41, '二百斤的孩儿', '3563433349@qq.com', 'dsa ', 'https://tse3-mm.cn.bing.net/th/id/OIP-C.1ChedSsZH_Uw30w2BhWAmQHaHa?pid=ImgDet&rs=1', '2022-09-25 08:32:32', 35, -1, b'0', 0000000004);
INSERT INTO `t_comment` VALUES (42, '二百斤的孩儿', '3563433349@qq.com', 'dada', 'https://tse3-mm.cn.bing.net/th/id/OIP-C.1ChedSsZH_Uw30w2BhWAmQHaHa?pid=ImgDet&rs=1', '2022-09-25 08:32:44', 35, 40, b'0', 0000000004);
INSERT INTO `t_comment` VALUES (43, '二百斤的孩儿', '3563433349@qq.com', '啊啊啊', 'https://tse3-mm.cn.bing.net/th/id/OIP-C.1ChedSsZH_Uw30w2BhWAmQHaHa?pid=ImgDet&rs=1', '2022-09-25 08:33:21', 35, 42, b'0', 0000000004);
INSERT INTO `t_comment` VALUES (44, '二百斤的孩儿', '3563433349@qq.com', '啊啊啊', 'https://tse3-mm.cn.bing.net/th/id/OIP-C.1ChedSsZH_Uw30w2BhWAmQHaHa?pid=ImgDet&rs=1', '2022-09-25 08:33:24', 35, 40, b'0', 0000000004);

-- ----------------------------
-- Table structure for t_follow
-- ----------------------------
DROP TABLE IF EXISTS `t_follow`;
CREATE TABLE `t_follow`  (
  `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  `t_userId` int(11) NOT NULL COMMENT '关注者的id',
  `t_followId` int(11) NOT NULL COMMENT '被关注者的id',
  `hasfollowed` bit(1) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 82 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_follow
-- ----------------------------
INSERT INTO `t_follow` VALUES (1, 4, 3, b'1');
INSERT INTO `t_follow` VALUES (4, 5, 4, b'1');
INSERT INTO `t_follow` VALUES (77, 10, 4, b'1');
INSERT INTO `t_follow` VALUES (79, 4, 9, b'1');
INSERT INTO `t_follow` VALUES (81, 10, 9, b'1');

-- ----------------------------
-- Table structure for t_friend
-- ----------------------------
DROP TABLE IF EXISTS `t_friend`;
CREATE TABLE `t_friend`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `blogaddress` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `blogname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `create_time` datetime(0) NULL DEFAULT NULL,
  `pictureaddress` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for t_tag
-- ----------------------------
DROP TABLE IF EXISTS `t_tag`;
CREATE TABLE `t_tag`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 16 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_tag
-- ----------------------------
INSERT INTO `t_tag` VALUES (9, '生活故事');
INSERT INTO `t_tag` VALUES (10, '方法论');
INSERT INTO `t_tag` VALUES (11, 'web');
INSERT INTO `t_tag` VALUES (12, '感情');
INSERT INTO `t_tag` VALUES (13, '后端');
INSERT INTO `t_tag` VALUES (14, 'Redis');
INSERT INTO `t_tag` VALUES (15, '缓存');

-- ----------------------------
-- Table structure for t_type
-- ----------------------------
DROP TABLE IF EXISTS `t_type`;
CREATE TABLE `t_type`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 62 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_type
-- ----------------------------
INSERT INTO `t_type` VALUES (43, 'javascript1');
INSERT INTO `t_type` VALUES (45, 'springmvc');
INSERT INTO `t_type` VALUES (57, 'spring');
INSERT INTO `t_type` VALUES (58, 'springboot');
INSERT INTO `t_type` VALUES (60, '文案');
INSERT INTO `t_type` VALUES (61, 'java');

-- ----------------------------
-- Table structure for t_user
-- ----------------------------
DROP TABLE IF EXISTS `t_user`;
CREATE TABLE `t_user`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `create_time` datetime(0) NULL DEFAULT NULL,s
  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '',
  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `type` int(11) NULL DEFAULT NULL,
  `update_time` datetime(0) NULL DEFAULT NULL,
  `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `fans` bigint(8) UNSIGNED ZEROFILL NULL DEFAULT NULL,
  `follows` bigint(8) UNSIGNED ZEROFILL NULL DEFAULT NULL,
  `introduction` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 14 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_user
-- ----------------------------
INSERT INTO `t_user` VALUES (3, 'https://tse2-mm.cn.bing.net/th/id/OIP-C.a7XL8ZnkCOc8GgZp9wgb3QHaHa?w=192&h=192&c=7&r=0&o=5&dpr=1.25&pid=1.7', NULL, '3563433349@qq.com', '某不知名赤木', '123456', NULL, NULL, 'admin', 00000001, 00000001, '');
INSERT INTO `t_user` VALUES (4, '/images/3ae57a5dd9623bafc0ea637a89d410c.jpg', '2022-08-29 10:37:38', '3563433349@qq.com', '二百斤的孩儿', '123456', NULL, NULL, 'user', 00000003, 00000002, '');
INSERT INTO `t_user` VALUES (5, NULL, NULL, '4564324@qq.com', '', '123789', NULL, NULL, 'zhangsan', 00000000, NULL, '');
INSERT INTO `t_user` VALUES (6, NULL, NULL, '4564324x@qq.com', 'blog:9f67d287-730f-4d39-b97b-f134f1f8831d', '1237895', NULL, NULL, 'zhangsan2', 00000000, NULL, '');
INSERT INTO `t_user` VALUES (7, NULL, NULL, 'xiaogouba@qq.com', '老牛', '456', NULL, NULL, 'zhangsan3', 00000000, NULL, '');
INSERT INTO `t_user` VALUES (8, 'https://tse1-mm.cn.bing.net/th/id/OIP-C.Hu0t5hoXLGyi15_F6mLrAQAAAA?w=192&h=192&c=7&r=0&o=5&dpr=1.25&pid=1.7', NULL, '666666@qq.com', '丹村', '789', NULL, NULL, 'lisi', 00000000, NULL, '');
INSERT INTO `t_user` VALUES (9, 'http://blog.juanfu.cc/usr/uploads/2022/07/1054950507.png', NULL, '456789@qq.com', '蛋纯', '789', NULL, NULL, 'zhangsan', NULL, NULL, '我是帅哥');
INSERT INTO `t_user` VALUES (10, '/images/bg2.jpg', '2022-08-29 10:37:38', '3563433349@qq.com', '牛魔等等的', '123456', NULL, NULL, 'danchun199', 00000000, 00000009, '我的dio答案');
INSERT INTO `t_user` VALUES (11, '/images/3ae57a5dd9623bafc0ea637a89d410c.jpg', '2022-09-24 02:59:56', '3633636@qq.com', '我是大帅哥', '123456', NULL, NULL, 'xiao', 00000000, 00000000, '孩子害羞，还没添加简介');
INSERT INTO `t_user` VALUES (12, '/images/avatar.png', '2022-09-25 07:18:58', '3543351235@qq.com', 'blog:d7ea6d15-0c41-4c70-a854-c11dbecca21e', '123456', NULL, NULL, 'llll', 00000000, 00000000, '孩子害羞，还没添加简介');
INSERT INTO `t_user` VALUES (13, '/images/avatar.png', '2022-09-25 08:30:34', '3563433349@qq.com', 'blog:7dd4222d-83dc-46bc-9665-d3209267d86f', '123456', NULL, NULL, 'dingtao', 00000000, 00000000, '孩子害羞，还没添加简介');

SET FOREIGN_KEY_CHECKS = 1;
